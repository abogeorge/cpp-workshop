===== DAY 1 ===== 

** Macros **
 - mai vechi, template functions permit mai multe verificari.
 * Special preprocessor directives (look them up)
 - #define smtg
 * try: (i++) * (i++)
 - macrourile sunt globale; litere mari si underscore; dupa definire ";"
 - macrourile sunt de evitat; de folosit cu variabile, nu cu expresii
 - String-ify and Token pasting
 - Def guards, incep cu _NAMESPACE_NUMEHEADER_H_
 - La includerea unui header intr-un cpp, se pot folosi def guard cu numele lui,
   optimizare la compilare
 - Pentru macro multiline se defineste cu do {} while(0) fara ";"
 Exercitiul 1: -

** Pointers **
 - SET "_NO_DEBUG_HEAP=1" - de adaugat in vs pentru a elimina rescanul la debug
 - NULL este void pointer de 0
 - nullptr introdus in c++11
 - auto_ptr are probleme de ownership: auto_ptr a = auto_ptr b; b va fi sters;
   a nu se folosi in containere.

** Refrences **
 - Syntactic sugar for pointers
 - Toate referinteles sunt const
 
===== DAY 2 ===== 

** Functions **
 - la get de obiecte const Object& getObject(); La retur de primitve, nu este nevoie de referinta.
 - in loc de return, in corpul functiei void foo(std::string& toReturn);
 - in c++ din cauza name mangling, la overloading conteaza doar semnatura functiei, nu si tipul returnat:
	int foo(int b);
	std::string foo(int b); // sunt acelasi lucru

** Pointers **
 - static const TestStruct& getConstant() - ramane cea mai buna varianta de apel	